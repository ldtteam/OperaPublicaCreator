import java.util.function.Predicate

if (project.hasProperty("usesCrowdin") && project.usesCrowdin.toString().toLowerCase() == "true") {
    apply plugin: 'de.undercouch.download'
}

apply plugin: 'java-library'

def projectUsesShadowing = false
if ((project.hasProperty("useShadowJar") && project.useShadowJar.toString().toLowerCase() == "true") ||
        (project.hasProperty("shadowRenamedNamespaces") &&  !project.shadowRenamedNamespaces.trim().isEmpty())
) {
    projectUsesShadowing = true
}

if (projectUsesShadowing) {
    apply plugin: 'com.github.johnrengelman.shadow'
}
if (project.hasProperty("curseId") && project.curseId.trim() != "") {
    project.logger.lifecycle("Enabling curse upload. Project id: " + project.curseId)
    apply plugin: 'com.matthewprenger.cursegradle'
}
apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'jacoco'
apply plugin: 'maven-publish'
apply plugin: 'idea'
apply plugin: 'eclipse'

repositories {
    jcenter()
    mavenCentral()
    maven {
        name 'LDTTeam - Modding'
        url 'https://ldtteam.jfrog.io/ldtteam/modding/'
    }
    flatDir {
        dirs {
            "libs"
        }
    }
}

static HashSet<String> newSet(String... members) {
    def set = new HashSet<String>();
    set.addAll(members);
    return set;
}

group = project.modGroup
version = project.exactMinecraftVersion + "-" + (System.getenv().containsKey("Version") ? System.getenv("Version") : project.modVersion)
archivesBaseName = project.modId

project.logger.lifecycle("Starting Gradle build for: " + project.modId + " with version: " + project.version)

def projectHasApi = true;
if (project.hasProperty("projectHasApi")) {
    projectHasApi = project.projectHasApi.toString().toLowerCase() == "true"

    if (!projectHasApi) {
        project.logger.lifecycle "Disabling API systems."
    }
}

def defaultSourceSetConfigurationDependencies = new HashSet<String>();
def availableSourceSets = new LinkedHashSet<String>();
def sourceSetConfigurationDependencies = new HashMap<String, Set<String>>();
def sourceSetSourceSetDependencies = new HashMap<String, Set<String>>();
def sourceSetAdditionalResourceDirectories = new HashMap<String, Set<String>>();
def sourceSetExcludedResourceDefinitions = new HashMap<String, Set<String>>();
def sourceSetIncludedResourceDefinitions = new HashMap<String, Set<String>>();
def sourceSetClassifiers = new HashMap<String, String>();

defaultSourceSetConfigurationDependencies.add("minecraft");

if (projectHasApi) {
    availableSourceSets.add("api");
}
availableSourceSets.add("main");
availableSourceSets.add("test");

sourceSetClassifiers.put("api", "api");
sourceSetClassifiers.put("main", "");
sourceSetClassifiers.put("test", "test");

if (projectHasApi) {
    sourceSetConfigurationDependencies.put("api", defaultSourceSetConfigurationDependencies);

    sourceSetSourceSetDependencies.put("main", newSet("api"));
    sourceSetSourceSetDependencies.put("test", newSet("api"));
}

sourceSetAdditionalResourceDirectories.put("main", newSet("src/datagen/generated/${project.modId}"))
sourceSetExcludedResourceDefinitions.put("main", newSet(".cache"))
sourceSetIncludedResourceDefinitions.put("main", newSet("**/**"))

void loadSourceSetConfiguration(Project project, String sourceSetName
                                , HashMap<String, Set<String>> sourceSetConfigurationDependencies
                                , HashMap<String, Set<String>> sourceSetSourceSetDependencies
                                , HashMap<String, Set<String>> sourceSetAdditionalResourceDirectories
                                , HashMap<String, Set<String>> sourceSetExcludedResourceDefinitions
                                , HashMap<String, Set<String>> sourceSetIncludedResourceDefinitions
                                , HashMap<String, String> sourceSetClassifiers
) {
    def configurationDependenciesPropertyName = sourceSetName + "ConfigurationDependencies"
    def sourceSetDependenciesPropertyName = sourceSetName + "SourceSetDependencies"
    def additionalResourcesPropertyName = sourceSetName + "ResourceDirectories"
    def excludeResourcesPropertyName = sourceSetName + "ExcludedResources"
    def includeResourcesPropertyName = sourceSetName + "IncludedResources"
    def customClassifierPropertyName = sourceSetName + "Classifier"

    if (project.hasProperty(configurationDependenciesPropertyName)) {
        sourceSetConfigurationDependencies.computeIfAbsent(sourceSetName, newName -> new HashSet<String>())
        Arrays.stream(project[configurationDependenciesPropertyName].split(";")).forEach(sourceSetConfigurationDependencies.get(sourceSetName)::add)
    }

    if (project.hasProperty(sourceSetDependenciesPropertyName)) {
        sourceSetSourceSetDependencies.computeIfAbsent(sourceSetName, newName -> new HashSet<String>())
        Arrays.stream(project[sourceSetDependenciesPropertyName].split(";")).forEach(sourceSetSourceSetDependencies.get(sourceSetName)::add)
    }

    if (project.hasProperty(additionalResourcesPropertyName)) {
        sourceSetAdditionalResourceDirectories.computeIfAbsent(sourceSetName, newName -> new HashSet<String>())
        Arrays.stream(project[additionalResourcesPropertyName].split(";")).forEach(sourceSetAdditionalResourceDirectories.get(sourceSetName)::add)
    }

    if (project.hasProperty(excludeResourcesPropertyName)) {
        sourceSetExcludedResourceDefinitions.computeIfAbsent(sourceSetName, newName -> new HashSet<String>())
        Arrays.stream(project[excludeResourcesPropertyName].split(";")).forEach(sourceSetExcludedResourceDefinitions.get(sourceSetName)::add)
    }

    if (project.hasProperty(includeResourcesPropertyName)) {
        sourceSetIncludedResourceDefinitions.computeIfAbsent(sourceSetName, newName -> new HashSet<String>())
        Arrays.stream(project[includeResourcesPropertyName].split(";")).forEach(sourceSetIncludedResourceDefinitions.get(sourceSetName)::add)
    }

    if (project.hasProperty(customClassifierPropertyName)) {
        sourceSetClassifiers.put(sourceSetName, project.customClassifierPropertyName)
    }
}

if (project.hasProperty("extendDefaultSourceSetConfiguration") && project.extendDefaultSourceSetConfiguration.toString().toLowerCase() == "true") {
    def additionalAvailableSourceSets = new HashSet<String>();
    if (project.hasProperty("additionalSourceSets")) {
        Arrays.stream(project.additionalSourceSets.split(";")).forEach(additionalAvailableSourceSets::add)
    }

    availableSourceSets.addAll(additionalAvailableSourceSets);
    additionalAvailableSourceSets.forEach(customSourceSetName -> {
        project.logger.lifecycle "Loading additional source set: ${customSourceSetName}"

        loadSourceSetConfiguration(project, customSourceSetName,
                sourceSetConfigurationDependencies
                , sourceSetSourceSetDependencies
                , sourceSetAdditionalResourceDirectories
                , sourceSetExcludedResourceDefinitions
                , sourceSetIncludedResourceDefinitions
                , sourceSetClassifiers);
    })

    if (projectHasApi) {
        loadSourceSetConfiguration(project, "api",
                sourceSetConfigurationDependencies
                , sourceSetSourceSetDependencies
                , sourceSetAdditionalResourceDirectories
                , sourceSetExcludedResourceDefinitions
                , sourceSetIncludedResourceDefinitions
                , sourceSetClassifiers);
    }
    loadSourceSetConfiguration(project, "main",
            sourceSetConfigurationDependencies
            , sourceSetSourceSetDependencies
            , sourceSetAdditionalResourceDirectories
            , sourceSetExcludedResourceDefinitions
            , sourceSetIncludedResourceDefinitions
            , sourceSetClassifiers);
    loadSourceSetConfiguration(project, "test",
            sourceSetConfigurationDependencies
            , sourceSetSourceSetDependencies
            , sourceSetAdditionalResourceDirectories
            , sourceSetExcludedResourceDefinitions
            , sourceSetIncludedResourceDefinitions
            , sourceSetClassifiers);
}

availableSourceSets.forEach(sourceSetName -> {
    project.logger.lifecycle "Configuring source set: ${sourceSetName}"
    def sourceSet = project.sourceSets.maybeCreate(sourceSetName)

    sourceSet.java.srcDir "src/${sourceSetName}/java"
    sourceSet.resources.srcDir "src/${sourceSetName}/resources"

    if (sourceSetConfigurationDependencies.containsKey(sourceSetName)) {
        def configurationDependencies = sourceSetConfigurationDependencies.get(sourceSetName);
        configurationDependencies.forEach(configurationName -> {
            project.logger.lifecycle " > Adding configuration: ${configurationName} as a dependency..."
            sourceSet.compileClasspath += project.configurations.getByName(configurationName);
        })
    }

    if (sourceSetSourceSetDependencies.containsKey(sourceSetName)) {
        def sourceSetDependencies = sourceSetSourceSetDependencies.get(sourceSetName)
        sourceSetDependencies.forEach(otherSourceSetName -> {
            project.logger.lifecycle " > Adding source set: ${otherSourceSetName} as a dependency..."
            def otherSourceSet = project.sourceSets.maybeCreate(otherSourceSetName);

            sourceSet.compileClasspath += otherSourceSet.output;
            sourceSet.runtimeClasspath += otherSourceSet.output;
        })
    }

    if (sourceSetIncludedResourceDefinitions.containsKey(sourceSetName)) {
        def includeDefinitions = sourceSetIncludedResourceDefinitions.get(sourceSetName)
        includeDefinitions.forEach(definition -> {
            project.logger.lifecycle " > Adding: ${definition} as an resource include spec..."
            sourceSet.resources.include definition
        })
    }

    if (sourceSetAdditionalResourceDirectories.containsKey(sourceSetName)) {
        def additionalResourceDirectories = sourceSetAdditionalResourceDirectories.get(sourceSetName);
        additionalResourceDirectories.forEach(directory -> {
            project.logger.lifecycle " > Adding: ${directory} as an resource directory..."
            sourceSet.resources.srcDirs += directory
        })
    }

    if (sourceSetExcludedResourceDefinitions.containsKey(sourceSetName)) {
        def excludeDefinitions = sourceSetExcludedResourceDefinitions.get(sourceSetName)
        excludeDefinitions.forEach(definition -> {
            project.logger.lifecycle " > Adding: ${definition} as an resource exclude spec..."
            sourceSet.resources.exclude definition
        })
    }
})

configurations {
    contained {
        transitive = false
    }
}

if (project.useJavaToolChains.toString().toLowerCase() == "true") {
    java.toolchain.languageVersion = JavaLanguageVersion.of(project.javaVersion)
} else {
    sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = project.javaVersion
}

def primaryJarSourceSets = new HashSet<String>()
if (projectHasApi) {
    primaryJarSourceSets.add("api")
}
primaryJarSourceSets.add("main")
if (project.hasProperty("primaryJarSourceSets")) {
    primaryJarSourceSets.clear();
    Arrays.stream(project.primaryJarSourceSets.split(";")).forEach(sourceSetName -> primaryJarSourceSets.add(sourceSetName as String))
}

def runtimeSourceSets = new HashSet<String>()
runtimeSourceSets.addAll(primaryJarSourceSets);
if (project.hasProperty("runtimeSourceSets")) {
    runtimeSourceSets.clear();
    Arrays.stream(project.runtimeSourceSets.split(";")).forEach(sourceSetName -> runtimeSourceSets.add(sourceSetName as String))
}

minecraft {
    mappings channel: project.mappingsChannel, version: project.mappingsVersion
    accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg')

    runs {
        client {
            workingDirectory project.file('runClient')
            property 'forge.logging.markers', ''
            property 'forge.logging.console.level', 'info'
            mods { n ->
                def mod = n.create(project.modId);
                runtimeSourceSets.forEach(sourceSetName -> {
                    def sourceSet = project.sourceSets[sourceSetName]
                    mod.source(sourceSet)
                })
            }
        }

        server {
            workingDirectory project.file('runServer')
            property 'forge.logging.markers', ''
            property 'forge.logging.console.level', 'info'
            mods { n ->
                def mod = n.create(project.modId);
                runtimeSourceSets.forEach(sourceSetName -> {
                    def sourceSet = project.sourceSets[sourceSetName]
                    mod.source(sourceSet)
                })
            }
        }

        data {
            workingDirectory project.file('runData')
            property 'forge.logging.markers', ''
            property 'forge.logging.console.level', 'info'
            args '--all', '--output', file("src/datagen/generated/${project.modId}"),
                    '--mod', "${project.modId}".toString(),
                    '--existing', sourceSets.main.resources.srcDirs[0]
            mods { n ->
                def mod = n.create(project.modId);
                runtimeSourceSets.forEach(sourceSetName -> {
                    def sourceSet = project.sourceSets[sourceSetName]
                    mod.source(sourceSet)
                })
            }
        }
    }
}


def useDefaultTestSystem = true;
def testSourceSets = new HashSet<String>();
def annotatedSourceSets = availableSourceSets;

testSourceSets.add("test");

if (project.hasProperty("useDefaultTestSystem") && project.useDefaultTestSystem.toString().toLowerCase() != "true") {
    useDefaultTestSystem = false;
}
if (project.hasProperty("testSourceSets")) {
    testSourceSets.clear();
    Arrays.stream(project.testSourceSets.split(";")).forEach(sourceSetName -> testSourceSets.add(sourceSetName as String))
}
if (project.hasProperty("annotatedSourceSets")) {
    annotatedSourceSets.clear();
    Arrays.stream(project.annotatedSourceSets.split(";")).forEach(sourceSetName -> annotatedSourceSets.add(sourceSetName as String))
}

if (useDefaultTestSystem) {
    def jUnitVersion = "4.13"
    def mockitoCoreVersion = "1.+"
    def powerMockModuleJUnit4Version = "2.0.2"
    def powerMockApiMockitoVersion = "2.0.2"
    def powerMockModuleJUnit4RuleEngineVersion = "2.0.2"
    def assertJCoreVersion = "3.9.0"
    def hamcrestAllVersion = "1.3"

    if (project.hasProperty("jUnitVersion")) {
        jUnitVersion = project.jUnitVersion;
    }
    if (project.hasProperty("mockitoCoreVersion")) {
        mockitoCoreVersion = project.mockitoCoreVersion;
    }
    if (project.hasProperty("powerMockVersion")) {
        powerMockModuleJUnit4Version = project.powerMockVersion;
        powerMockApiMockitoVersion = project.powerMockVersion;
        powerMockModuleJUnit4RuleEngineVersion = project.powerMockVersion;
    }
    if (project.hasProperty("powerMockModuleJUnit4Version")) {
        powerMockModuleJUnit4Version = project.powerMockModuleJUnit4Version;
    }
    if (project.hasProperty("powerMockApiMockitoVersion")) {
        powerMockApiMockitoVersion = project.powerMockApiMockitoVersion;
    }
    if (project.hasProperty("powerMockModuleJUnit4RuleEngineVersion")) {
        powerMockModuleJUnit4RuleEngineVersion = project.powerMockModuleJUnit4RuleEngineVersion;
    }
    if (project.hasProperty("assertJCoreVersion")) {
        assertJCoreVersion = project.assertJCoreVersion;
    }
    if (project.hasProperty("hamcrestAllVersion")) {
        hamcrestAllVersion = project.hamcrestAllVersion;
    }

    testSourceSets.forEach(sourceSetName -> {
        def configurationName = sourceSetName + "Implementation"
        if (sourceSetName == "main") {
            configurationName = "implementation"
        }

        dependencies.add(configurationName,  "junit:junit:${jUnitVersion}");
        dependencies.add(configurationName,  "org.mockito:mockito-core:${mockitoCoreVersion}");
        dependencies.add(configurationName,  "org.powermock:powermock-module-junit4:${powerMockModuleJUnit4Version}");
        dependencies.add(configurationName,  "org.powermock:powermock-api-mockito2:${powerMockApiMockitoVersion}");
        dependencies.add(configurationName,  "org.powermock:powermock-module-junit4-rule-agent:${powerMockModuleJUnit4RuleEngineVersion}");
        dependencies.add(configurationName,  "org.assertj:assertj-core:${assertJCoreVersion}");
        dependencies.add(configurationName,  "org.hamcrest:hamcrest-all:${hamcrestAllVersion}");
    })
}

def intelliJAnnotationsVersion = "21.0.1"
if (project.hasProperty("intelliJAnnotationsVersion")) {
    intelliJAnnotationsVersion = project.intelliJAnnotationsVersion;
}

annotatedSourceSets.forEach(sourceSetName -> {
    def configurationName = sourceSetName + "Implementation"
    if (sourceSetName == "main") {
        configurationName = "implementation"
    }

    dependencies.add(configurationName,  "org.jetbrains:annotations:${intelliJAnnotationsVersion}");
})

dependencies {
    minecraft "net.minecraftforge:forge:${project.exactMinecraftVersion}-${project.forgeVersion}"
}

def primaryJarClassifier = 'universal'
if (project.hasProperty("primaryJarClassifier")) {
    primaryJarClassifier = project.primaryJarClassifier;
}

def automaticModuleName = project.modId
if (project.hasProperty("automaticModuleName")) {
    automaticModuleName = project.automaticModuleName;
}

def isFMLLibrary = false;
if (project.hasProperty("isFMLLibrary") && project.isFMLLibrary.toString().toLowerCase() == "true") {
    isFMLLibrary = true;
}

jar {
    primaryJarSourceSets.forEach(sourceSetName -> {
        project.jar.from project.sourceSets[sourceSetName].output
    })

    classifier primaryJarClassifier
    if (projectUsesShadowing) {
        classifier 'slim'
    }

    manifest {
        attributes([
                'Maven-Artifact'          : "${project.group}:${project.archivesBaseName}:${project.version}",
                "Specification-Title"     : project.modId,
                "Specification-Vendor"    : "ldtteam",
                "Specification-Version"   : "1", // We are version 1 of ourselves
                "Implementation-Title"    : project.name,
                "Implementation-Version"  : "${project.version}",
                "Implementation-Vendor"   : "ldtteam",
                "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
                "Automatic-Module-Name"   : automaticModuleName
        ])

        if (isFMLLibrary) {
            attributes([
                'FMLModType'          : "LIBRARY",
            ])
        }
    }
}

def additionalSourceSetJars = new HashSet<String>();
if (projectHasApi) {
    additionalSourceSetJars.add("api")
}
if (project.hasProperty("additionalSourceSetJars")) {
    additionalSourceSetJars.clear();
    Arrays.stream(project.additionalSourceSetJars.split(";")).forEach(sourceSetName -> additionalSourceSetJars.add(sourceSetName as String))
}

additionalSourceSetJars.forEach(additionalSourceSet -> {
    String additionalSourceSetJavaDocTaskName = additionalSourceSet + "Javadoc"
    String additionalSourceSetPackageJavaDocTaskName = additionalSourceSet + "PackageJavadoc"
    String additionalSourceSetJarTaskName = additionalSourceSet + "Jar"
    String additionalSourceSetSourcesTaskName = additionalSourceSet + "Sources"
    String additionalSourceSetBuildTask = additionalSourceSet + "Build"

    String additionalSourceSetJavadocClassifier = sourceSetClassifiers.getOrDefault(additionalSourceSet, additionalSourceSet.toLowerCase()) + "-javadoc"
    String additionalSourceSetSourcesClassifier = sourceSetClassifiers.getOrDefault(additionalSourceSet, additionalSourceSet.toLowerCase()) + "-sources"

    org.gradle.api.tasks.javadoc.Javadoc javaDocTask = project.tasks.create(additionalSourceSetJavaDocTaskName, Javadoc.class);
    javaDocTask.setClasspath(sourceSets[additionalSourceSet].getCompileClasspath())
    javaDocTask.group 'documentation'
    javaDocTask.source = sourceSets[additionalSourceSet].allJava

    org.gradle.api.tasks.bundling.Jar javadocJarTask = project.tasks.create(additionalSourceSetPackageJavaDocTaskName, org.gradle.api.tasks.bundling.Jar.class)
    javadocJarTask.dependsOn javaDocTask
    javadocJarTask.group 'packaging'
    javadocJarTask.from javaDocTask
    javadocJarTask.getArchiveClassifier().set(additionalSourceSetJavadocClassifier)

    org.gradle.api.tasks.bundling.Jar outputJarTask = project.tasks.create(additionalSourceSetJarTaskName, org.gradle.api.tasks.bundling.Jar.class)
    outputJarTask.group 'build'
    outputJarTask.from sourceSets[additionalSourceSet].output
    outputJarTask.getArchiveClassifier().set(additionalSourceSet.toLowerCase())

    org.gradle.api.tasks.bundling.Jar sourcesJarTask = project.tasks.create(additionalSourceSetSourcesTaskName, org.gradle.api.tasks.bundling.Jar.class)
    sourcesJarTask.group 'sources'
    sourcesJarTask.duplicatesStrategy 'exclude'
    sourcesJarTask.from sourceSets[additionalSourceSet].allJava
    sourcesJarTask.getArchiveClassifier().set(additionalSourceSetSourcesClassifier)

    Task sourceSetBuildTask = project.tasks.create(additionalSourceSetBuildTask)
    sourceSetBuildTask.group 'build'
    sourceSetBuildTask.dependsOn javaDocTask
    sourceSetBuildTask.dependsOn javadocJarTask
    sourceSetBuildTask.dependsOn outputJarTask
    sourceSetBuildTask.dependsOn sourcesJarTask

    project.tasks.build.dependsOn sourceSetBuildTask
})

task sourcesJar(type: Jar) { it ->
    classifier = 'sources'
    duplicatesStrategy 'exclude'

    primaryJarSourceSets.forEach(sourceSetName -> {
        it.from project.sourceSets[sourceSetName].allSource
    })
}

javadoc {it ->
    primaryJarSourceSets.forEach(sourceSetName -> {
        it.source +=  project.sourceSets[sourceSetName].allJava
    })
}

task packageJavadoc(type: Jar) { task ->
    task.dependsOn javadoc
    task.from javadoc
    task.classifier = 'javadoc'
}

project.tasks.build.dependsOn sourcesJar
project.tasks.build.dependsOn packageJavadoc


if (projectUsesShadowing) {
    shadowJar { shadowJarTask ->
        primaryJarSourceSets.forEach(sourceSetName -> {
            shadowJarTask.from project.sourceSets[sourceSetName].output
        })

        shadowJarTask.configurations = [project.configurations.contained]

        if (project.hasProperty("shadowRenamedNamespaces") && !project.shadowRenamedNamespaces.trim().isEmpty()) {
            project.shadowRenamedNamespaces.split(',').each { n ->
                if (n.contains(':')) {
                    def namespaceSpecs = n.split(':');
                    project.logger.lifecycle "Shading ${namespaceSpecs[0]} to ${namespaceSpecs[1]}"
                    shadowJarTask.relocate namespaceSpecs[0], namespaceSpecs[1]
                }
            }
        }

        shadowJarTask.classifier = primaryJarClassifier
    }
}


def reobfuscationSourceSets = new HashSet<String>();
if (projectHasApi) {
    reobfuscationSourceSets.add("api");
}
reobfuscationSourceSets.add("main");
if (project.hasProperty("reobfuscationSourceSets")) {
    reobfuscationSourceSets.clear();
    Arrays.stream(project.reobfuscationSourceSets.split(";")).forEach(sourceSetName -> reobfuscationSourceSets.add(sourceSetName as String))
}

def reobfuscationContainer = project.reobf
reobfuscationSourceSets.forEach(sourceSetName -> {
    def sourceSet = project.sourceSets[sourceSetName]
    def taskName = sourceSetName + "Jar"
    if (sourceSetName == "main") {
        taskName = "jar"
    }

    def task = reobfuscationContainer.create(taskName)
    task.getClasspath().from(sourceSet.getCompileClasspath())
    task.group 'reobfuscation'

    if (sourceSetName == "main" && projectUsesShadowing) {
        taskName = "shadowJar"
        def shadowTask = reobfuscationContainer.create(taskName)
        shadowTask.group 'reobfuscation'
        shadowTask.getClasspath().from(sourceSet.getCompileClasspath())
    }
})

def publishableSourceSets = new HashSet<String>()
if (projectHasApi) {
    publishableSourceSets.add("api")
}
publishableSourceSets.add("main")
if (project.hasProperty("publishableSourceSets")) {
    publishableSourceSets.clear();
    Arrays.stream(project.publishableSourceSets.split(";")).forEach(sourceSetName -> publishableSourceSets.add(sourceSetName as String))
}

artifacts { it ->
    publishableSourceSets.forEach(sourceSetName -> {
        String javaDocTaskName = sourceSetName + "PackageJavadoc"
        String jarTaskName = sourceSetName + "Jar"
        String sourceTaskName = sourceSetName + "Sources"
        if (sourceSetName == "main") {
            javaDocTaskName = "packageJavadoc"
            jarTaskName = "jar"
            sourceTaskName = "sourcesJar"
        }

        it.add("default", project.tasks[javaDocTaskName])
        it.add("default", project.tasks[jarTaskName])
        it.add("default", project.tasks[sourceTaskName])

        if (sourceSetName == "main" && projectUsesShadowing) {
            it.add("default", project.tasks.shadowJar);
        }
    })
}

publishing {
    publications {
        mavenJava(MavenPublication) {pub ->
            from project.components.java

            artifactId project.modId

            publishableSourceSets.forEach(sourceSetName -> {
                String javaDocTaskName = sourceSetName + "PackageJavadoc"
                String jarTaskName = sourceSetName + "Jar"
                String sourceTaskName = sourceSetName + "Sources"
                if (sourceSetName == "main") {
                    javaDocTaskName = "packageJavadoc"
                    jarTaskName = "jar"
                    sourceTaskName = "sourcesJar"
                }

                pub.artifacts.artifact(project.tasks[javaDocTaskName])
                if (sourceSetName != "main") {
                    pub.artifacts.artifact(project.tasks[jarTaskName])
                }
                pub.artifacts.artifact(project.tasks[sourceTaskName])
            })

            pom {
                url = project.githubUrl
                licenses {
                    license {
                        name = 'GNU GENERAL PUBLIC LICENSE Version 3'
                        url = 'https://www.gnu.org/licenses/gpl-3.0.en.html'
                    }
                }
                developers {
                    developer {
                        id = 'OrionDevelopment'
                        name = 'Marc Hermans'
                        email = 'marc.hermans@ldtteam.com'
                    }
                    developer {
                        id = 'Raycoms'
                        name = 'Ray Neiheiser'
                        email = 'ray.neiheiser@ldtteam.com'
                    }
                }
                contributors {
                    contributor {
                        id = 'ldtteam'
                        name = 'Let\'s Develop Together - Team'
                        email = 'info@ldtteam.com'
                    }
                }
                scm {
                    connection = project.gitUrl
                    developerConnection = project.gitConnectUrl
                    url = project.projectUrl
                }
            }

            //Replace all deobf dependencies with normal jar references.
            pom.withXml { xmlProvider ->
                def dependencies = asNode().dependencies
                def allDeps = dependencies.'*';

                allDeps.findAll {
                    println it
                }

                // Remove forge deps
                allDeps.findAll() { el ->
                    el.artifactId.text() == 'forge' && el.groupId.text() == 'net.minecraftforge'
                }.forEach() { el ->
                    el.parent().remove(el)
                }
                //remove forgegradle's mapped suffix from versions & set as optional so anyone else doesn't inherit them
                allDeps.findAll() { el ->
                    el.version.text().contains('_mapped_')
                }.each { el ->
                    def version = el.version
                    version.each {
                        it.setValue(it.text().substring(0, it.text().indexOf('_mapped_')))
                    }
                }
            }
        }
    }

    if (System.getenv().containsKey("LDTTeamJfrogUsername") && System.getenv().containsKey("LDTTeamJfrogPassword")) {
        repositories {
            maven {
                name 'LDTTeamJfrog'
                credentials {
                    username System.getenv().get("LDTTeamJfrogUsername")
                    password System.getenv().get("LDTTeamJfrogPassword")
                }
                url 'https://ldtteam.jfrog.io/ldtteam/mods-maven'
            }
        }
    }

    repositories {
        maven {
            name 'RepoDirectory'
            url 'file://' + rootProject.file('repo').getAbsolutePath()
        }
    }
}

task setupDecompWorkspace {
    doLast {
    }
}

task setupCIWorkspace {
    doLast {
    }
}

if (project.hasProperty("curseId") && project.curseId.trim() != "") {
    project.curseforge { cf ->
        if (System.getenv().CURSEAPIKEY != null && System.getenv().CURSERELEASETYPE != null) {
            cf.apiKey = System.getenv().CURSEAPIKEY

            project { cp ->
                cp.id = project.curseId
                cp.addGameVersion(project.exactMinecraftVersion)
                cp.changelog = file('build/changelog.md')
                cp.changelogType = 'markdown'
                cp.releaseType = System.getenv().CURSERELEASETYPE

                if (!project.additionalMinecraftVersions.trim().isEmpty()) {
                    project.additionalMinecraftVersions.split(",").each { v ->
                        cp.addGameVersion(v)
                    }
                }

                if (projectUsesShadowing) {
                    cp.mainArtifact(shadowJar)
                } else {
                    cp.mainArtifact(jar)
                }

                publishableSourceSets.forEach(sourceSetName -> {
                    String javaDocTaskName = sourceSetName + "PackageJavadoc"
                    String jarTaskName = sourceSetName + "Jar"
                    String sourceTaskName = sourceSetName + "Sources"
                    if (sourceSetName == "main") {
                        javaDocTaskName = "packageJavadoc"
                        jarTaskName = "jar"
                        sourceTaskName = "sourcesJar"
                    }

                    cp.addArtifact(project.tasks[javaDocTaskName])
                    if (sourceSetName != "main" || projectUsesShadowing) {
                        cp.addArtifact(project.tasks[jarTaskName])
                    }
                    cp.addArtifact(project.tasks[sourceTaskName])
                })
            }
        }
    }

    task("createChangelog") {
        group = 'upload'

        doLast {
            def teamCityURL = "https://buildsystem.ldtteam.com/"
            def file = new FileOutputStream("build/changelog.md")
            def out = new BufferedOutputStream(file)
            def changesXML = new XmlSlurper().parse(teamCityURL + "guestAuth/app/rest/changes?locator=build:(id:" + teamcity["teamcity.build.id"] + ")")

            def changes = changesXML.change
            out << "# ${project.modId} Changelog \n"
            out << "## Version: _" + version + "_ \n"

            if (changes.size() > 0) {
                for (int i = 0; i < changes.size(); i++) {
                    def changeDetailsURL = teamCityURL + "guestAuth/app/rest/changes/id:" + changes[i].@id.text()
                    def changeDetailsXml = new XmlSlurper().parse(changeDetailsURL)
                    def changeComment = changeDetailsXml.comment.text().trim()

                    out << "* " + changeComment + "\n"
                }
            } else {
                out << "No Changes detected!"
            }

            out.close()
        }
    }
}
else
{
    task("curseforge") {
        //Noop
    }

    task("createChangelog") {
        //Noop
    }
}


idea {
    module {
        inheritOutputDirs = true
    }
}


if (project.hasProperty("usesCrowdin") && project.usesCrowdin.toString().toLowerCase() == "true") {
    task downloadCrowdin() {
        ext {
            output = file('build/crowdin_raw.zip')
            update = file('build/crowdin.json')
            id = project.crowdinId
        }
        onlyIf {
            System.getenv().containsKey("crowdinKey") && !project.gradle.startParameter.isOffline()
        }
        doLast {
            download {
                src "https://api.crowdin.com/api/project/${id}/export?key=${System.getenv("crowdinKey")}&json"
                dest update
                overwrite true
            }
            if (!update.text.contains('success')) {
                throw new RuntimeException("Crowdin export failed, see ${update} for more info")
            }
            download {
                src "https://api.crowdin.com/api/project/${id}/download/all.zip?key=${System.getenv("crowdinKey")}"
                dest output
                overwrite true
            }
        }
    }

    task crowdin(type: Zip) {
        dependsOn downloadCrowdin
        onlyIf {
            !downloadCrowdin.state.skipped
        }
        baseName = project.name
        version = project.version
        classifier = 'crowdin'
        destinationDir = file('build/distributions')
        from(zipTree(downloadCrowdin.output)){
            eachFile {
                if (!it.path.startsWith('assets/')) {
                    it.relativePath = new RelativePath(true, it.relativePath.segments.drop(4))
                }
            }
            exclude { it.isDirectory() }
            rename { it.toLowerCase() }
        }
    }
}

tasks.withType(org.gradle.api.tasks.Copy.class, {task ->
    task.duplicatesStrategy 'exclude'
})

tasks.withType(Jar.class, {task ->
    task.duplicatesStrategy 'exclude'
})

tasks.withType(GenerateModuleMetadata) {
    enabled = false
}

fileTree('gradle') {
    include '**/*.gradle'
}.visit { FileVisitDetails details ->
    if (details.file.isDirectory())
        return

    if (details.file.name.contains("local"))
        return

    project.logger.lifecycle "Loading additoinal configuration from: ${details.file.path}"
    apply from: details.file.path
}

if (project.file("gradle/local.gradle").exists()) {
    project.logger.lifecycle "Loading additoinal configuration from: ${project.file("gradle/local.gradle").path}"
    apply from: "gradle/local.gradle"
}
